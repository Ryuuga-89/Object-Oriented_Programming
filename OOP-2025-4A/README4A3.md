# 問題4A-3

Java Collection Frameworkの`Map`を用いて、氏名を表す`oop.ex4A3.Person`と学籍番号を表す文字列の間の相互変換を行う。
そのためのクラス`oop.ex4A3.IDTable`を実装せよ。
`IDTable`に最低限度定義しなければならないメソッドは指定するが、フィールドについては`Map`（またはその子クラス）を使うという点以外は、**`static`フィールドを使ってはならないという制限を除き**自由にして良い。
また、実装の利便性のために追加のメソッドを実装しても良い。

`IDTable`は`public`メソッドとして以下の5つを持つ。
初期の`IDTable`はこの5つのメソッドのひな形のみである。

1. `Person`を取り、その`Person`（と同値なオブジェクト）が登録済みであれば対応する文字列を返す`getID`メソッド。登録されていなければ`null`を返す。
2. 文字列を取り、その文字列が学籍番号として登録済みであれば対応する`Person`を返す`getName`メソッド。登録されていなければ`null`を返す。
3. `Person`と学籍番号を表す文字列を取り、その二つの間での相互変換を登録する`register`メソッド。`register`メソッドは値を返さないものとする。
4. `Person`を取り、その`Person`が登録済みであれば対応関係を消去する`remove`メソッド。`remove`メソッドは登録済みで消去されれば`true`、登録されていなければ`false`を返す。
5. 文字列を取り、その文字列が学籍番号として登録済みであれば消去する`remove`メソッド。返し値は4と同様。

4と5は同名だが、ミスではなくメソッドのオーバーロードである。
3の`register`の引数が既に登録されていた場合、それぞれの登録を消去した上で新たに登録を行うこと。以前の情報が参照されないようにせよ。
`IDTable`のコンストラクタは無引数のものが`main`メソッドを実行できれば自由にして良い。




`Person`クラスは同姓同名を同一人物（同値なオブジェクト）としてしまうが、ここでは問題がないものとする。
<!-- 実際には当然起こりうる問題なので、同じインターフェースに限定するなら`Person`に追加で一意に特定できる識別子か、他の同姓同名と区別するための情報を付加するはずである（普通はそのために学籍番号があるので、学籍番号を外部テーブルに問い合わせることはほとんどない）。また、インターフェースを変えるなら`getID`を`Set`を返すようにする、という方法もある。 -->

### 実行例

    小林 隆志は見つかりませんでした
    03_24949は見つかりませんでした
    小林 隆志->03_24949
    03_24949<-小林 隆志
    工大 太郎->22B12345
    22B12345<-工大 太郎
    工大 花子は登録されていませんでした
    22B12345を消去しました
    工大 太郎は見つかりませんでした
    22B12345は見つかりませんでした
    小林 隆志->07M38381
    03_24949は見つかりませんでした
